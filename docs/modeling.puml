@startuml
!theme vibrant
title Diagrama de Classes - Class Warriors

skinparam classAttributeIconSize 0
skinparam linetype ortho

package "main" {
  class Main {
    + {static} main(String[] args)
  }
}

package "adapters" {
  class CliAdapter implements GameOutputPort, Runnable {
    - scanner: Scanner
    - gameService: GameInputPort
    + run()
    + presentRoundResult(...)
    + presentGameOver(...)
  }

  class CsvLogPersistenceAdapter implements LogPersistancePort {
    - file: Path
    - inMemoryEntries: List<BattleLogEntry>
    + save(BattleLog)
    + append(BattleLog)
    + appendOne(BattleLogEntry)
    + load(): BattleLog
  }

   class InMemoryLogPersistenceAdapter implements LogPersistancePort {
    - inMemoryEntries: List<BattleLogEntry>
    + save(BattleLog)
    + append(BattleLog)
    + appendOne(BattleLogEntry)
    + load(): BattleLog
  }
}

package "application" {
  package "ports" {
    interface GameInputPort {
      + startGame(int, Difficulty)
      + playTurn()
      + endGame()
      + isGameOver(): boolean
    }

    interface GameOutputPort {
      + presentRoundResult(List<BattleLogEntry>, GameState)
      + presentGameOver(GameState)
    }

    interface LogPersistancePort {
      + save(BattleLog)
      + append(BattleLog)
      + appendOne(BattleLogEntry)
      + load(): BattleLog
    }
  }

  package "service" {
    class GameService implements GameInputPort {
      - gameOutputPort: GameOutputPort
      - logPersistancePort: LogPersistancePort
      - turnEngine: TurnEngine
      - gameState: GameState
      + startGame(int, Difficulty)
      + playTurn()
      + endGame()
    }
  }
}

package "domain" {
  package "game" {
    class GameState {
      - heroes: List<Hero>
      - monsters: List<Monster>
      - difficulty: Difficulty
      - currentRound: int
      + incrementRound()
    }

    enum Difficulty {
      EASY
      MEDIUM
      HARD
      - monsterMultiplier: double
      - monsterCountFactor: double
    }
  }

  package "battle" {
    class TurnEngine {
      - {static} RANDOM: Random
      - {static} CRITICAL_HIT_CHANCE: double
      + getTurnOrder(List<Hero>, List<Monster>): List<Entity>
      + executeTurn(...): List<BattleLogEntry>
      - chooseTarget(...): Entity
      - resolveAttack(Entity, Entity): AttackResult
    }

    class Attack {
      - attacker: Entity
      - defensePenetration: double
      - baseDamage: double
    }

    class DefenseResult {
      - effectiveDamage: double
      - specialAction: String
    }

    enum AttackResult {
      MISSED
      HIT
      CRITICAL_HIT
    }
  }

  package "logs" {
    record BattleLog {
      - entries: List<BattleLogEntry>
    }

    class BattleLogEntry {
      - attackerName: String
      - targetName: String
      - roundNumber: int
      - rawDamage: double
      - effectiveDamage: double
      - result: AttackResult
      - killingBlow: boolean
      - specialAction: String
      - timestamp: Instant
      + {static} of(...): BattleLogEntry
      + {static} csvHeader(): String
      + toCsvRow(): String
      + toHumanReadable(): String
    }
  }

  package "character" {
    abstract class Entity {
      # name: String
      # hitPoints: double
      # attackPower: int
      # defense: int
      # dexterity: int
      # speed: int
      + {abstract} performAttack(Entity): Attack
      + receiveDamage(Attack): DefenseResult
      + isAlive(): boolean
      + applyDifficulty(Difficulty)
    }

    package "hero" {
      abstract class Hero extends Entity {}
      class Archer extends Hero {
        + performAttack(Entity): Attack
      }
      class Mage extends Hero {
        + performAttack(Entity): Attack
      }
      class Rogue extends Hero {
        + performAttack(Entity): Attack
        + receiveDamage(Attack): DefenseResult
      }
      class Warrior extends Hero {
        + performAttack(Entity): Attack
        + receiveDamage(Attack): DefenseResult
      }

      class HeroFactory {
        - {static} HERO_TYPES: List<String>
        + {static} createHero(String, String): Hero
        + {static} createRandomHero(String): Hero
      }
    }

    package "monster" {
      abstract class Monster extends Entity {
        + decideTarget(List<Hero>): Entity
      }
      class Dragon extends Monster {
        + performAttack(Entity): Attack
        + receiveDamage(Attack): DefenseResult
      }
      class Goblin extends Monster {
        + performAttack(Entity): Attack
        + receiveDamage(Attack): DefenseResult
      }
      class Orc extends Monster {
        + performAttack(Entity): Attack
      }

      class MonsterFactory {
        - {static} MONSTER_TYPES: List<String>
        + {static} createMonster(String, String, Difficulty): Monster
        + {static} createRandomMonster(String, Difficulty): Monster
      }
    }
  }
}


' --- Relacionamentos ---

' Entry Point
Main .> GameService
Main .> CliAdapter
Main .> CsvLogPersistenceAdapter

' Application Core Dependencies
GameService o--> GameState
GameService o--> TurnEngine
GameService ..> GameOutputPort
GameService ..> LogPersistancePort
GameService ..> HeroFactory
GameService ..> MonsterFactory

' Adapter Dependencies
CliAdapter ..> GameInputPort
CliAdapter ..> GameState
CliAdapter ..> BattleLogEntry

' Domain Dependencies
GameState "1" *-- "0..*" Hero
GameState "1" *-- "0..*" Monster
GameState -- Difficulty

TurnEngine ..> Entity
TurnEngine ..> Attack
TurnEngine ..> DefenseResult
TurnEngine ..> BattleLogEntry
TurnEngine ..> AttackResult

BattleLog *-- "0..*" BattleLogEntry
BattleLogEntry -- AttackResult

Entity <.. Attack : "attacker"
Entity <.. TurnEngine

MonsterFactory ..> Difficulty
MonsterFactory ..> Dragon
MonsterFactory ..> Goblin
MonsterFactory ..> Orc

HeroFactory ..> Archer
HeroFactory ..> Mage
HeroFactory ..> Rogue
HeroFactory ..> Warrior
@enduml